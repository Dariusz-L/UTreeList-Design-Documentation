    
# Introduction

The project described in this documentation is a graphical user interface library of reusable graphical lists and list elements for hierarchical and interconnected data manipulation, organization and presentation. 

There are several purposes for this project to develop, all of them will be described in detail later. The same goes for the documentation itself.

However, main guilty here is another application developed. Its identified features so far share a large extent of functionality, so to reduce an unneccesarily repeated work it seems the best to have a reusable and easily extentable common basis.

The project should display some portion of qualities. This is why the documentating all of them and tracking is essential.

Simple now, easily extentable.

The list elements could be transformed into vertical or horizontal layout.
They could contain different data, could be quickly 

However, generally speaking, everything lies around the project complexity. It is really hard to make progress in predictable and useful way without well detailed and organized description of the features and their qualities.

There were few attempts of implementing it already

Lack of understanding consequences, amount of work, importance

Exploring

Important to develop it from simplest but useful way, but allowing for easy extension in the future, an
Every single use cases
Impact 


documnetation as for a public reader, so it is well organized na dcan even learned from

Pragmatic approach to documnetation, parallel development - technical experimentation.
Avoid procrastination by exploring unnessacry subjects or problems instead of solving essential problems - it applies to writing this documentation, 
some things might be

There are several reasons for this documentation to exists - all of them will be described in detail later. 
Generally speaking, the complexity of the main problem to be solved by it arised to such an extent, so it is really hard to make progress, because of lack of understanding consequences, amount of work, importance. The list of requirements is big, and there is need to discover, explore, clarify, distill, prioritize every single use case
has to be .
Write readable code in which support potential easy ex

As for domain problem of course I mean there are specific ones, but it can be used for anything really, this is why it has to be realt versatile

The key is to progress the project to the point where it is usable enough for the target application, so the original domain problem might be started to be worked on.  
And it has to be done as quickly as possible, so later appropriate time might be delegated for both original domain problem solving and further development in parallel on daily basis.
